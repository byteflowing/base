// Code generated by Kitex v0.14.1. DO NOT EDIT.

package baseservice

import (
	"context"
	"errors"
	base "github.com/byteflowing/base/kitex_gen/base"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
)

var errInvalidMessageType = errors.New("invalid message type for pkg method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"SendCaptcha": kitex.NewMethodInfo(
		sendCaptchaHandler,
		newSendCaptchaArgs,
		newSendCaptchaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifyCaptcha": kitex.NewMethodInfo(
		verifyCaptchaHandler,
		newVerifyCaptchaArgs,
		newVerifyCaptchaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"PagingGetSmsMessages": kitex.NewMethodInfo(
		pagingGetSmsMessagesHandler,
		newPagingGetSmsMessagesArgs,
		newPagingGetSmsMessagesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SendPhoneCaptcha": kitex.NewMethodInfo(
		sendPhoneCaptchaHandler,
		newSendPhoneCaptchaArgs,
		newSendPhoneCaptchaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SendEmailCaptcha": kitex.NewMethodInfo(
		sendEmailCaptchaHandler,
		newSendEmailCaptchaArgs,
		newSendEmailCaptchaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Login": kitex.NewMethodInfo(
		loginHandler,
		newLoginArgs,
		newLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Logout": kitex.NewMethodInfo(
		logoutHandler,
		newLogoutArgs,
		newLogoutResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ForceLogoutBySessionId": kitex.NewMethodInfo(
		forceLogoutBySessionIdHandler,
		newForceLogoutBySessionIdArgs,
		newForceLogoutBySessionIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RefreshToken": kitex.NewMethodInfo(
		refreshTokenHandler,
		newRefreshTokenArgs,
		newRefreshTokenResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifyToken": kitex.NewMethodInfo(
		verifyTokenHandler,
		newVerifyTokenArgs,
		newVerifyTokenResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AddUser": kitex.NewMethodInfo(
		addUserHandler,
		newAddUserArgs,
		newAddUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"BatchAddUsers": kitex.NewMethodInfo(
		batchAddUsersHandler,
		newBatchAddUsersArgs,
		newBatchAddUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateUser": kitex.NewMethodInfo(
		updateUserHandler,
		newUpdateUserArgs,
		newUpdateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteUser": kitex.NewMethodInfo(
		deleteUserHandler,
		newDeleteUserArgs,
		newDeleteUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"BatchDeleteUsers": kitex.NewMethodInfo(
		batchDeleteUsersHandler,
		newBatchDeleteUsersArgs,
		newBatchDeleteUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserByNumber": kitex.NewMethodInfo(
		getUserByNumberHandler,
		newGetUserByNumberArgs,
		newGetUserByNumberResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"PagingGetUsers": kitex.NewMethodInfo(
		pagingGetUsersHandler,
		newPagingGetUsersArgs,
		newPagingGetUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserLoginLogs": kitex.NewMethodInfo(
		getUserLoginLogsHandler,
		newGetUserLoginLogsArgs,
		newGetUserLoginLogsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"PagingGetLoginLogs": kitex.NewMethodInfo(
		pagingGetLoginLogsHandler,
		newPagingGetLoginLogsArgs,
		newPagingGetLoginLogsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	baseServiceServiceInfo                = NewServiceInfo()
	baseServiceServiceInfoForClient       = NewServiceInfoForClient()
	baseServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return baseServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return baseServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return baseServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "BaseService"
	handlerType := (*base.BaseService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "base",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func sendCaptchaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.SendCaptchaReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).SendCaptcha(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SendCaptchaArgs:
		success, err := handler.(base.BaseService).SendCaptcha(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SendCaptchaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSendCaptchaArgs() interface{} {
	return &SendCaptchaArgs{}
}

func newSendCaptchaResult() interface{} {
	return &SendCaptchaResult{}
}

type SendCaptchaArgs struct {
	Req *base.SendCaptchaReq
}

func (p *SendCaptchaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SendCaptchaArgs) Unmarshal(in []byte) error {
	msg := new(base.SendCaptchaReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SendCaptchaArgs_Req_DEFAULT *base.SendCaptchaReq

func (p *SendCaptchaArgs) GetReq() *base.SendCaptchaReq {
	if !p.IsSetReq() {
		return SendCaptchaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SendCaptchaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SendCaptchaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SendCaptchaResult struct {
	Success *base.SendCaptchaResp
}

var SendCaptchaResult_Success_DEFAULT *base.SendCaptchaResp

func (p *SendCaptchaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SendCaptchaResult) Unmarshal(in []byte) error {
	msg := new(base.SendCaptchaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SendCaptchaResult) GetSuccess() *base.SendCaptchaResp {
	if !p.IsSetSuccess() {
		return SendCaptchaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SendCaptchaResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.SendCaptchaResp)
}

func (p *SendCaptchaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendCaptchaResult) GetResult() interface{} {
	return p.Success
}

func verifyCaptchaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.VerifyCaptchaReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).VerifyCaptcha(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifyCaptchaArgs:
		success, err := handler.(base.BaseService).VerifyCaptcha(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifyCaptchaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifyCaptchaArgs() interface{} {
	return &VerifyCaptchaArgs{}
}

func newVerifyCaptchaResult() interface{} {
	return &VerifyCaptchaResult{}
}

type VerifyCaptchaArgs struct {
	Req *base.VerifyCaptchaReq
}

func (p *VerifyCaptchaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifyCaptchaArgs) Unmarshal(in []byte) error {
	msg := new(base.VerifyCaptchaReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifyCaptchaArgs_Req_DEFAULT *base.VerifyCaptchaReq

func (p *VerifyCaptchaArgs) GetReq() *base.VerifyCaptchaReq {
	if !p.IsSetReq() {
		return VerifyCaptchaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifyCaptchaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifyCaptchaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifyCaptchaResult struct {
	Success *base.VerifyCaptchaResp
}

var VerifyCaptchaResult_Success_DEFAULT *base.VerifyCaptchaResp

func (p *VerifyCaptchaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifyCaptchaResult) Unmarshal(in []byte) error {
	msg := new(base.VerifyCaptchaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifyCaptchaResult) GetSuccess() *base.VerifyCaptchaResp {
	if !p.IsSetSuccess() {
		return VerifyCaptchaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifyCaptchaResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.VerifyCaptchaResp)
}

func (p *VerifyCaptchaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifyCaptchaResult) GetResult() interface{} {
	return p.Success
}

func pagingGetSmsMessagesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.PagingGetSmsMessagesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).PagingGetSmsMessages(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PagingGetSmsMessagesArgs:
		success, err := handler.(base.BaseService).PagingGetSmsMessages(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PagingGetSmsMessagesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPagingGetSmsMessagesArgs() interface{} {
	return &PagingGetSmsMessagesArgs{}
}

func newPagingGetSmsMessagesResult() interface{} {
	return &PagingGetSmsMessagesResult{}
}

type PagingGetSmsMessagesArgs struct {
	Req *base.PagingGetSmsMessagesReq
}

func (p *PagingGetSmsMessagesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PagingGetSmsMessagesArgs) Unmarshal(in []byte) error {
	msg := new(base.PagingGetSmsMessagesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PagingGetSmsMessagesArgs_Req_DEFAULT *base.PagingGetSmsMessagesReq

func (p *PagingGetSmsMessagesArgs) GetReq() *base.PagingGetSmsMessagesReq {
	if !p.IsSetReq() {
		return PagingGetSmsMessagesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PagingGetSmsMessagesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PagingGetSmsMessagesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PagingGetSmsMessagesResult struct {
	Success *base.PagingGetSmsMessagesResp
}

var PagingGetSmsMessagesResult_Success_DEFAULT *base.PagingGetSmsMessagesResp

func (p *PagingGetSmsMessagesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PagingGetSmsMessagesResult) Unmarshal(in []byte) error {
	msg := new(base.PagingGetSmsMessagesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PagingGetSmsMessagesResult) GetSuccess() *base.PagingGetSmsMessagesResp {
	if !p.IsSetSuccess() {
		return PagingGetSmsMessagesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PagingGetSmsMessagesResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.PagingGetSmsMessagesResp)
}

func (p *PagingGetSmsMessagesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PagingGetSmsMessagesResult) GetResult() interface{} {
	return p.Success
}

func sendPhoneCaptchaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.SendPhoneCaptchaReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).SendPhoneCaptcha(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SendPhoneCaptchaArgs:
		success, err := handler.(base.BaseService).SendPhoneCaptcha(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SendPhoneCaptchaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSendPhoneCaptchaArgs() interface{} {
	return &SendPhoneCaptchaArgs{}
}

func newSendPhoneCaptchaResult() interface{} {
	return &SendPhoneCaptchaResult{}
}

type SendPhoneCaptchaArgs struct {
	Req *base.SendPhoneCaptchaReq
}

func (p *SendPhoneCaptchaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SendPhoneCaptchaArgs) Unmarshal(in []byte) error {
	msg := new(base.SendPhoneCaptchaReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SendPhoneCaptchaArgs_Req_DEFAULT *base.SendPhoneCaptchaReq

func (p *SendPhoneCaptchaArgs) GetReq() *base.SendPhoneCaptchaReq {
	if !p.IsSetReq() {
		return SendPhoneCaptchaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SendPhoneCaptchaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SendPhoneCaptchaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SendPhoneCaptchaResult struct {
	Success *base.SendPhoneCaptchaResp
}

var SendPhoneCaptchaResult_Success_DEFAULT *base.SendPhoneCaptchaResp

func (p *SendPhoneCaptchaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SendPhoneCaptchaResult) Unmarshal(in []byte) error {
	msg := new(base.SendPhoneCaptchaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SendPhoneCaptchaResult) GetSuccess() *base.SendPhoneCaptchaResp {
	if !p.IsSetSuccess() {
		return SendPhoneCaptchaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SendPhoneCaptchaResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.SendPhoneCaptchaResp)
}

func (p *SendPhoneCaptchaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendPhoneCaptchaResult) GetResult() interface{} {
	return p.Success
}

func sendEmailCaptchaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.SendEmailCaptchaReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).SendEmailCaptcha(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SendEmailCaptchaArgs:
		success, err := handler.(base.BaseService).SendEmailCaptcha(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SendEmailCaptchaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSendEmailCaptchaArgs() interface{} {
	return &SendEmailCaptchaArgs{}
}

func newSendEmailCaptchaResult() interface{} {
	return &SendEmailCaptchaResult{}
}

type SendEmailCaptchaArgs struct {
	Req *base.SendEmailCaptchaReq
}

func (p *SendEmailCaptchaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SendEmailCaptchaArgs) Unmarshal(in []byte) error {
	msg := new(base.SendEmailCaptchaReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SendEmailCaptchaArgs_Req_DEFAULT *base.SendEmailCaptchaReq

func (p *SendEmailCaptchaArgs) GetReq() *base.SendEmailCaptchaReq {
	if !p.IsSetReq() {
		return SendEmailCaptchaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SendEmailCaptchaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SendEmailCaptchaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SendEmailCaptchaResult struct {
	Success *base.SendEmailCaptchaResp
}

var SendEmailCaptchaResult_Success_DEFAULT *base.SendEmailCaptchaResp

func (p *SendEmailCaptchaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SendEmailCaptchaResult) Unmarshal(in []byte) error {
	msg := new(base.SendEmailCaptchaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SendEmailCaptchaResult) GetSuccess() *base.SendEmailCaptchaResp {
	if !p.IsSetSuccess() {
		return SendEmailCaptchaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SendEmailCaptchaResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.SendEmailCaptchaResp)
}

func (p *SendEmailCaptchaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendEmailCaptchaResult) GetResult() interface{} {
	return p.Success
}

func loginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.LoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).Login(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *LoginArgs:
		success, err := handler.(base.BaseService).Login(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newLoginArgs() interface{} {
	return &LoginArgs{}
}

func newLoginResult() interface{} {
	return &LoginResult{}
}

type LoginArgs struct {
	Req *base.LoginReq
}

func (p *LoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LoginArgs) Unmarshal(in []byte) error {
	msg := new(base.LoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LoginArgs_Req_DEFAULT *base.LoginReq

func (p *LoginArgs) GetReq() *base.LoginReq {
	if !p.IsSetReq() {
		return LoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LoginResult struct {
	Success *base.LoginResp
}

var LoginResult_Success_DEFAULT *base.LoginResp

func (p *LoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LoginResult) Unmarshal(in []byte) error {
	msg := new(base.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LoginResult) GetSuccess() *base.LoginResp {
	if !p.IsSetSuccess() {
		return LoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.LoginResp)
}

func (p *LoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LoginResult) GetResult() interface{} {
	return p.Success
}

func logoutHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.LogoutReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).Logout(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *LogoutArgs:
		success, err := handler.(base.BaseService).Logout(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LogoutResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newLogoutArgs() interface{} {
	return &LogoutArgs{}
}

func newLogoutResult() interface{} {
	return &LogoutResult{}
}

type LogoutArgs struct {
	Req *base.LogoutReq
}

func (p *LogoutArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LogoutArgs) Unmarshal(in []byte) error {
	msg := new(base.LogoutReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LogoutArgs_Req_DEFAULT *base.LogoutReq

func (p *LogoutArgs) GetReq() *base.LogoutReq {
	if !p.IsSetReq() {
		return LogoutArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LogoutArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LogoutArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LogoutResult struct {
	Success *base.LogoutResp
}

var LogoutResult_Success_DEFAULT *base.LogoutResp

func (p *LogoutResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LogoutResult) Unmarshal(in []byte) error {
	msg := new(base.LogoutResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LogoutResult) GetSuccess() *base.LogoutResp {
	if !p.IsSetSuccess() {
		return LogoutResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LogoutResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.LogoutResp)
}

func (p *LogoutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LogoutResult) GetResult() interface{} {
	return p.Success
}

func forceLogoutBySessionIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.ForceLogoutBySessionIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).ForceLogoutBySessionId(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ForceLogoutBySessionIdArgs:
		success, err := handler.(base.BaseService).ForceLogoutBySessionId(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ForceLogoutBySessionIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newForceLogoutBySessionIdArgs() interface{} {
	return &ForceLogoutBySessionIdArgs{}
}

func newForceLogoutBySessionIdResult() interface{} {
	return &ForceLogoutBySessionIdResult{}
}

type ForceLogoutBySessionIdArgs struct {
	Req *base.ForceLogoutBySessionIdReq
}

func (p *ForceLogoutBySessionIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ForceLogoutBySessionIdArgs) Unmarshal(in []byte) error {
	msg := new(base.ForceLogoutBySessionIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ForceLogoutBySessionIdArgs_Req_DEFAULT *base.ForceLogoutBySessionIdReq

func (p *ForceLogoutBySessionIdArgs) GetReq() *base.ForceLogoutBySessionIdReq {
	if !p.IsSetReq() {
		return ForceLogoutBySessionIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ForceLogoutBySessionIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ForceLogoutBySessionIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ForceLogoutBySessionIdResult struct {
	Success *base.ForceLogoutBySessionIdResp
}

var ForceLogoutBySessionIdResult_Success_DEFAULT *base.ForceLogoutBySessionIdResp

func (p *ForceLogoutBySessionIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ForceLogoutBySessionIdResult) Unmarshal(in []byte) error {
	msg := new(base.ForceLogoutBySessionIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ForceLogoutBySessionIdResult) GetSuccess() *base.ForceLogoutBySessionIdResp {
	if !p.IsSetSuccess() {
		return ForceLogoutBySessionIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ForceLogoutBySessionIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.ForceLogoutBySessionIdResp)
}

func (p *ForceLogoutBySessionIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ForceLogoutBySessionIdResult) GetResult() interface{} {
	return p.Success
}

func refreshTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.RefreshTokenReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).RefreshToken(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RefreshTokenArgs:
		success, err := handler.(base.BaseService).RefreshToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RefreshTokenResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRefreshTokenArgs() interface{} {
	return &RefreshTokenArgs{}
}

func newRefreshTokenResult() interface{} {
	return &RefreshTokenResult{}
}

type RefreshTokenArgs struct {
	Req *base.RefreshTokenReq
}

func (p *RefreshTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RefreshTokenArgs) Unmarshal(in []byte) error {
	msg := new(base.RefreshTokenReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RefreshTokenArgs_Req_DEFAULT *base.RefreshTokenReq

func (p *RefreshTokenArgs) GetReq() *base.RefreshTokenReq {
	if !p.IsSetReq() {
		return RefreshTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RefreshTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RefreshTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RefreshTokenResult struct {
	Success *base.RefreshTokenResp
}

var RefreshTokenResult_Success_DEFAULT *base.RefreshTokenResp

func (p *RefreshTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RefreshTokenResult) Unmarshal(in []byte) error {
	msg := new(base.RefreshTokenResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RefreshTokenResult) GetSuccess() *base.RefreshTokenResp {
	if !p.IsSetSuccess() {
		return RefreshTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RefreshTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.RefreshTokenResp)
}

func (p *RefreshTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RefreshTokenResult) GetResult() interface{} {
	return p.Success
}

func verifyTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.VerifyTokenReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).VerifyToken(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifyTokenArgs:
		success, err := handler.(base.BaseService).VerifyToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifyTokenResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifyTokenArgs() interface{} {
	return &VerifyTokenArgs{}
}

func newVerifyTokenResult() interface{} {
	return &VerifyTokenResult{}
}

type VerifyTokenArgs struct {
	Req *base.VerifyTokenReq
}

func (p *VerifyTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifyTokenArgs) Unmarshal(in []byte) error {
	msg := new(base.VerifyTokenReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifyTokenArgs_Req_DEFAULT *base.VerifyTokenReq

func (p *VerifyTokenArgs) GetReq() *base.VerifyTokenReq {
	if !p.IsSetReq() {
		return VerifyTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifyTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifyTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifyTokenResult struct {
	Success *base.VerifyTokenResp
}

var VerifyTokenResult_Success_DEFAULT *base.VerifyTokenResp

func (p *VerifyTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifyTokenResult) Unmarshal(in []byte) error {
	msg := new(base.VerifyTokenResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifyTokenResult) GetSuccess() *base.VerifyTokenResp {
	if !p.IsSetSuccess() {
		return VerifyTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifyTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.VerifyTokenResp)
}

func (p *VerifyTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifyTokenResult) GetResult() interface{} {
	return p.Success
}

func addUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.AddUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).AddUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AddUserArgs:
		success, err := handler.(base.BaseService).AddUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAddUserArgs() interface{} {
	return &AddUserArgs{}
}

func newAddUserResult() interface{} {
	return &AddUserResult{}
}

type AddUserArgs struct {
	Req *base.AddUserReq
}

func (p *AddUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AddUserArgs) Unmarshal(in []byte) error {
	msg := new(base.AddUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddUserArgs_Req_DEFAULT *base.AddUserReq

func (p *AddUserArgs) GetReq() *base.AddUserReq {
	if !p.IsSetReq() {
		return AddUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AddUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AddUserResult struct {
	Success *base.AddUserResp
}

var AddUserResult_Success_DEFAULT *base.AddUserResp

func (p *AddUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AddUserResult) Unmarshal(in []byte) error {
	msg := new(base.AddUserResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddUserResult) GetSuccess() *base.AddUserResp {
	if !p.IsSetSuccess() {
		return AddUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.AddUserResp)
}

func (p *AddUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AddUserResult) GetResult() interface{} {
	return p.Success
}

func batchAddUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.BatchAddUsersReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).BatchAddUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *BatchAddUsersArgs:
		success, err := handler.(base.BaseService).BatchAddUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*BatchAddUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newBatchAddUsersArgs() interface{} {
	return &BatchAddUsersArgs{}
}

func newBatchAddUsersResult() interface{} {
	return &BatchAddUsersResult{}
}

type BatchAddUsersArgs struct {
	Req *base.BatchAddUsersReq
}

func (p *BatchAddUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *BatchAddUsersArgs) Unmarshal(in []byte) error {
	msg := new(base.BatchAddUsersReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var BatchAddUsersArgs_Req_DEFAULT *base.BatchAddUsersReq

func (p *BatchAddUsersArgs) GetReq() *base.BatchAddUsersReq {
	if !p.IsSetReq() {
		return BatchAddUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *BatchAddUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *BatchAddUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type BatchAddUsersResult struct {
	Success *base.BatchAddUsersResp
}

var BatchAddUsersResult_Success_DEFAULT *base.BatchAddUsersResp

func (p *BatchAddUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *BatchAddUsersResult) Unmarshal(in []byte) error {
	msg := new(base.BatchAddUsersResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *BatchAddUsersResult) GetSuccess() *base.BatchAddUsersResp {
	if !p.IsSetSuccess() {
		return BatchAddUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *BatchAddUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.BatchAddUsersResp)
}

func (p *BatchAddUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BatchAddUsersResult) GetResult() interface{} {
	return p.Success
}

func updateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.UpdateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).UpdateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateUserArgs:
		success, err := handler.(base.BaseService).UpdateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateUserArgs() interface{} {
	return &UpdateUserArgs{}
}

func newUpdateUserResult() interface{} {
	return &UpdateUserResult{}
}

type UpdateUserArgs struct {
	Req *base.UpdateUserReq
}

func (p *UpdateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateUserArgs) Unmarshal(in []byte) error {
	msg := new(base.UpdateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateUserArgs_Req_DEFAULT *base.UpdateUserReq

func (p *UpdateUserArgs) GetReq() *base.UpdateUserReq {
	if !p.IsSetReq() {
		return UpdateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateUserResult struct {
	Success *base.UpdateUserResp
}

var UpdateUserResult_Success_DEFAULT *base.UpdateUserResp

func (p *UpdateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateUserResult) Unmarshal(in []byte) error {
	msg := new(base.UpdateUserResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateUserResult) GetSuccess() *base.UpdateUserResp {
	if !p.IsSetSuccess() {
		return UpdateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.UpdateUserResp)
}

func (p *UpdateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserResult) GetResult() interface{} {
	return p.Success
}

func deleteUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.DeleteUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).DeleteUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteUserArgs:
		success, err := handler.(base.BaseService).DeleteUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteUserArgs() interface{} {
	return &DeleteUserArgs{}
}

func newDeleteUserResult() interface{} {
	return &DeleteUserResult{}
}

type DeleteUserArgs struct {
	Req *base.DeleteUserReq
}

func (p *DeleteUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteUserArgs) Unmarshal(in []byte) error {
	msg := new(base.DeleteUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteUserArgs_Req_DEFAULT *base.DeleteUserReq

func (p *DeleteUserArgs) GetReq() *base.DeleteUserReq {
	if !p.IsSetReq() {
		return DeleteUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteUserResult struct {
	Success *base.DeleteUserResp
}

var DeleteUserResult_Success_DEFAULT *base.DeleteUserResp

func (p *DeleteUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteUserResult) Unmarshal(in []byte) error {
	msg := new(base.DeleteUserResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteUserResult) GetSuccess() *base.DeleteUserResp {
	if !p.IsSetSuccess() {
		return DeleteUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.DeleteUserResp)
}

func (p *DeleteUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteUserResult) GetResult() interface{} {
	return p.Success
}

func batchDeleteUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.BatchDeleteUsersReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).BatchDeleteUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *BatchDeleteUsersArgs:
		success, err := handler.(base.BaseService).BatchDeleteUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*BatchDeleteUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newBatchDeleteUsersArgs() interface{} {
	return &BatchDeleteUsersArgs{}
}

func newBatchDeleteUsersResult() interface{} {
	return &BatchDeleteUsersResult{}
}

type BatchDeleteUsersArgs struct {
	Req *base.BatchDeleteUsersReq
}

func (p *BatchDeleteUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *BatchDeleteUsersArgs) Unmarshal(in []byte) error {
	msg := new(base.BatchDeleteUsersReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var BatchDeleteUsersArgs_Req_DEFAULT *base.BatchDeleteUsersReq

func (p *BatchDeleteUsersArgs) GetReq() *base.BatchDeleteUsersReq {
	if !p.IsSetReq() {
		return BatchDeleteUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *BatchDeleteUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *BatchDeleteUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type BatchDeleteUsersResult struct {
	Success *base.BatchDeleteUsersResp
}

var BatchDeleteUsersResult_Success_DEFAULT *base.BatchDeleteUsersResp

func (p *BatchDeleteUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *BatchDeleteUsersResult) Unmarshal(in []byte) error {
	msg := new(base.BatchDeleteUsersResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *BatchDeleteUsersResult) GetSuccess() *base.BatchDeleteUsersResp {
	if !p.IsSetSuccess() {
		return BatchDeleteUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *BatchDeleteUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.BatchDeleteUsersResp)
}

func (p *BatchDeleteUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BatchDeleteUsersResult) GetResult() interface{} {
	return p.Success
}

func getUserByNumberHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.GetUserByNumberReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).GetUserByNumber(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserByNumberArgs:
		success, err := handler.(base.BaseService).GetUserByNumber(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserByNumberResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserByNumberArgs() interface{} {
	return &GetUserByNumberArgs{}
}

func newGetUserByNumberResult() interface{} {
	return &GetUserByNumberResult{}
}

type GetUserByNumberArgs struct {
	Req *base.GetUserByNumberReq
}

func (p *GetUserByNumberArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserByNumberArgs) Unmarshal(in []byte) error {
	msg := new(base.GetUserByNumberReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserByNumberArgs_Req_DEFAULT *base.GetUserByNumberReq

func (p *GetUserByNumberArgs) GetReq() *base.GetUserByNumberReq {
	if !p.IsSetReq() {
		return GetUserByNumberArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserByNumberArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserByNumberArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserByNumberResult struct {
	Success *base.GetUserByNumberResp
}

var GetUserByNumberResult_Success_DEFAULT *base.GetUserByNumberResp

func (p *GetUserByNumberResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserByNumberResult) Unmarshal(in []byte) error {
	msg := new(base.GetUserByNumberResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserByNumberResult) GetSuccess() *base.GetUserByNumberResp {
	if !p.IsSetSuccess() {
		return GetUserByNumberResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserByNumberResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.GetUserByNumberResp)
}

func (p *GetUserByNumberResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserByNumberResult) GetResult() interface{} {
	return p.Success
}

func pagingGetUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.PagingGetUsersReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).PagingGetUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PagingGetUsersArgs:
		success, err := handler.(base.BaseService).PagingGetUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PagingGetUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPagingGetUsersArgs() interface{} {
	return &PagingGetUsersArgs{}
}

func newPagingGetUsersResult() interface{} {
	return &PagingGetUsersResult{}
}

type PagingGetUsersArgs struct {
	Req *base.PagingGetUsersReq
}

func (p *PagingGetUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PagingGetUsersArgs) Unmarshal(in []byte) error {
	msg := new(base.PagingGetUsersReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PagingGetUsersArgs_Req_DEFAULT *base.PagingGetUsersReq

func (p *PagingGetUsersArgs) GetReq() *base.PagingGetUsersReq {
	if !p.IsSetReq() {
		return PagingGetUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PagingGetUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PagingGetUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PagingGetUsersResult struct {
	Success *base.PagingGetUsersResp
}

var PagingGetUsersResult_Success_DEFAULT *base.PagingGetUsersResp

func (p *PagingGetUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PagingGetUsersResult) Unmarshal(in []byte) error {
	msg := new(base.PagingGetUsersResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PagingGetUsersResult) GetSuccess() *base.PagingGetUsersResp {
	if !p.IsSetSuccess() {
		return PagingGetUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PagingGetUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.PagingGetUsersResp)
}

func (p *PagingGetUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PagingGetUsersResult) GetResult() interface{} {
	return p.Success
}

func getUserLoginLogsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.GetUserLoginLogsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).GetUserLoginLogs(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserLoginLogsArgs:
		success, err := handler.(base.BaseService).GetUserLoginLogs(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserLoginLogsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserLoginLogsArgs() interface{} {
	return &GetUserLoginLogsArgs{}
}

func newGetUserLoginLogsResult() interface{} {
	return &GetUserLoginLogsResult{}
}

type GetUserLoginLogsArgs struct {
	Req *base.GetUserLoginLogsReq
}

func (p *GetUserLoginLogsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserLoginLogsArgs) Unmarshal(in []byte) error {
	msg := new(base.GetUserLoginLogsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserLoginLogsArgs_Req_DEFAULT *base.GetUserLoginLogsReq

func (p *GetUserLoginLogsArgs) GetReq() *base.GetUserLoginLogsReq {
	if !p.IsSetReq() {
		return GetUserLoginLogsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserLoginLogsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserLoginLogsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserLoginLogsResult struct {
	Success *base.GetUserLoginLogsResp
}

var GetUserLoginLogsResult_Success_DEFAULT *base.GetUserLoginLogsResp

func (p *GetUserLoginLogsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserLoginLogsResult) Unmarshal(in []byte) error {
	msg := new(base.GetUserLoginLogsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserLoginLogsResult) GetSuccess() *base.GetUserLoginLogsResp {
	if !p.IsSetSuccess() {
		return GetUserLoginLogsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserLoginLogsResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.GetUserLoginLogsResp)
}

func (p *GetUserLoginLogsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserLoginLogsResult) GetResult() interface{} {
	return p.Success
}

func pagingGetLoginLogsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(base.PagingGetLoginLogsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(base.BaseService).PagingGetLoginLogs(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PagingGetLoginLogsArgs:
		success, err := handler.(base.BaseService).PagingGetLoginLogs(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PagingGetLoginLogsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPagingGetLoginLogsArgs() interface{} {
	return &PagingGetLoginLogsArgs{}
}

func newPagingGetLoginLogsResult() interface{} {
	return &PagingGetLoginLogsResult{}
}

type PagingGetLoginLogsArgs struct {
	Req *base.PagingGetLoginLogsReq
}

func (p *PagingGetLoginLogsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PagingGetLoginLogsArgs) Unmarshal(in []byte) error {
	msg := new(base.PagingGetLoginLogsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PagingGetLoginLogsArgs_Req_DEFAULT *base.PagingGetLoginLogsReq

func (p *PagingGetLoginLogsArgs) GetReq() *base.PagingGetLoginLogsReq {
	if !p.IsSetReq() {
		return PagingGetLoginLogsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PagingGetLoginLogsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PagingGetLoginLogsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PagingGetLoginLogsResult struct {
	Success *base.PagingGetLoginLogsResp
}

var PagingGetLoginLogsResult_Success_DEFAULT *base.PagingGetLoginLogsResp

func (p *PagingGetLoginLogsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PagingGetLoginLogsResult) Unmarshal(in []byte) error {
	msg := new(base.PagingGetLoginLogsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PagingGetLoginLogsResult) GetSuccess() *base.PagingGetLoginLogsResp {
	if !p.IsSetSuccess() {
		return PagingGetLoginLogsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PagingGetLoginLogsResult) SetSuccess(x interface{}) {
	p.Success = x.(*base.PagingGetLoginLogsResp)
}

func (p *PagingGetLoginLogsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PagingGetLoginLogsResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) SendCaptcha(ctx context.Context, Req *base.SendCaptchaReq) (r *base.SendCaptchaResp, err error) {
	var _args SendCaptchaArgs
	_args.Req = Req
	var _result SendCaptchaResult
	if err = p.c.Call(ctx, "SendCaptcha", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifyCaptcha(ctx context.Context, Req *base.VerifyCaptchaReq) (r *base.VerifyCaptchaResp, err error) {
	var _args VerifyCaptchaArgs
	_args.Req = Req
	var _result VerifyCaptchaResult
	if err = p.c.Call(ctx, "VerifyCaptcha", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PagingGetSmsMessages(ctx context.Context, Req *base.PagingGetSmsMessagesReq) (r *base.PagingGetSmsMessagesResp, err error) {
	var _args PagingGetSmsMessagesArgs
	_args.Req = Req
	var _result PagingGetSmsMessagesResult
	if err = p.c.Call(ctx, "PagingGetSmsMessages", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SendPhoneCaptcha(ctx context.Context, Req *base.SendPhoneCaptchaReq) (r *base.SendPhoneCaptchaResp, err error) {
	var _args SendPhoneCaptchaArgs
	_args.Req = Req
	var _result SendPhoneCaptchaResult
	if err = p.c.Call(ctx, "SendPhoneCaptcha", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SendEmailCaptcha(ctx context.Context, Req *base.SendEmailCaptchaReq) (r *base.SendEmailCaptchaResp, err error) {
	var _args SendEmailCaptchaArgs
	_args.Req = Req
	var _result SendEmailCaptchaResult
	if err = p.c.Call(ctx, "SendEmailCaptcha", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Login(ctx context.Context, Req *base.LoginReq) (r *base.LoginResp, err error) {
	var _args LoginArgs
	_args.Req = Req
	var _result LoginResult
	if err = p.c.Call(ctx, "Login", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Logout(ctx context.Context, Req *base.LogoutReq) (r *base.LogoutResp, err error) {
	var _args LogoutArgs
	_args.Req = Req
	var _result LogoutResult
	if err = p.c.Call(ctx, "Logout", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ForceLogoutBySessionId(ctx context.Context, Req *base.ForceLogoutBySessionIdReq) (r *base.ForceLogoutBySessionIdResp, err error) {
	var _args ForceLogoutBySessionIdArgs
	_args.Req = Req
	var _result ForceLogoutBySessionIdResult
	if err = p.c.Call(ctx, "ForceLogoutBySessionId", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RefreshToken(ctx context.Context, Req *base.RefreshTokenReq) (r *base.RefreshTokenResp, err error) {
	var _args RefreshTokenArgs
	_args.Req = Req
	var _result RefreshTokenResult
	if err = p.c.Call(ctx, "RefreshToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifyToken(ctx context.Context, Req *base.VerifyTokenReq) (r *base.VerifyTokenResp, err error) {
	var _args VerifyTokenArgs
	_args.Req = Req
	var _result VerifyTokenResult
	if err = p.c.Call(ctx, "VerifyToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddUser(ctx context.Context, Req *base.AddUserReq) (r *base.AddUserResp, err error) {
	var _args AddUserArgs
	_args.Req = Req
	var _result AddUserResult
	if err = p.c.Call(ctx, "AddUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) BatchAddUsers(ctx context.Context, Req *base.BatchAddUsersReq) (r *base.BatchAddUsersResp, err error) {
	var _args BatchAddUsersArgs
	_args.Req = Req
	var _result BatchAddUsersResult
	if err = p.c.Call(ctx, "BatchAddUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateUser(ctx context.Context, Req *base.UpdateUserReq) (r *base.UpdateUserResp, err error) {
	var _args UpdateUserArgs
	_args.Req = Req
	var _result UpdateUserResult
	if err = p.c.Call(ctx, "UpdateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteUser(ctx context.Context, Req *base.DeleteUserReq) (r *base.DeleteUserResp, err error) {
	var _args DeleteUserArgs
	_args.Req = Req
	var _result DeleteUserResult
	if err = p.c.Call(ctx, "DeleteUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) BatchDeleteUsers(ctx context.Context, Req *base.BatchDeleteUsersReq) (r *base.BatchDeleteUsersResp, err error) {
	var _args BatchDeleteUsersArgs
	_args.Req = Req
	var _result BatchDeleteUsersResult
	if err = p.c.Call(ctx, "BatchDeleteUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserByNumber(ctx context.Context, Req *base.GetUserByNumberReq) (r *base.GetUserByNumberResp, err error) {
	var _args GetUserByNumberArgs
	_args.Req = Req
	var _result GetUserByNumberResult
	if err = p.c.Call(ctx, "GetUserByNumber", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PagingGetUsers(ctx context.Context, Req *base.PagingGetUsersReq) (r *base.PagingGetUsersResp, err error) {
	var _args PagingGetUsersArgs
	_args.Req = Req
	var _result PagingGetUsersResult
	if err = p.c.Call(ctx, "PagingGetUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserLoginLogs(ctx context.Context, Req *base.GetUserLoginLogsReq) (r *base.GetUserLoginLogsResp, err error) {
	var _args GetUserLoginLogsArgs
	_args.Req = Req
	var _result GetUserLoginLogsResult
	if err = p.c.Call(ctx, "GetUserLoginLogs", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PagingGetLoginLogs(ctx context.Context, Req *base.PagingGetLoginLogsReq) (r *base.PagingGetLoginLogsResp, err error) {
	var _args PagingGetLoginLogsArgs
	_args.Req = Req
	var _result PagingGetLoginLogsResult
	if err = p.c.Call(ctx, "PagingGetLoginLogs", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
