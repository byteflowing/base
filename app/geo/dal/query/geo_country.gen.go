// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/byteflowing/base/app/geo/dal/model"
)

func newGeoCountry(db *gorm.DB, opts ...gen.DOOption) geoCountry {
	_geoCountry := geoCountry{}

	_geoCountry.geoCountryDo.UseDB(db, opts...)
	_geoCountry.geoCountryDo.UseModel(&model.GeoCountry{})

	tableName := _geoCountry.geoCountryDo.TableName()
	_geoCountry.ALL = field.NewAsterisk(tableName)
	_geoCountry.ID = field.NewInt64(tableName, "id")
	_geoCountry.Cca2 = field.NewString(tableName, "cca2")
	_geoCountry.Cca3 = field.NewString(tableName, "cca3")
	_geoCountry.Ccn3 = field.NewString(tableName, "ccn3")
	_geoCountry.Flag = field.NewString(tableName, "flag")
	_geoCountry.Continent = field.NewString(tableName, "continent")
	_geoCountry.SubContinent = field.NewString(tableName, "sub_continent")
	_geoCountry.MultiLang = field.NewString(tableName, "multi_lang")
	_geoCountry.Independent = field.NewBool(tableName, "independent")
	_geoCountry.IsActive = field.NewBool(tableName, "is_active")
	_geoCountry.CreatedAt = field.NewTime(tableName, "created_at")
	_geoCountry.UpdatedAt = field.NewTime(tableName, "updated_at")
	_geoCountry.DeletedAt = field.NewField(tableName, "deleted_at")

	_geoCountry.fillFieldMap()

	return _geoCountry
}

type geoCountry struct {
	geoCountryDo geoCountryDo

	ALL          field.Asterisk
	ID           field.Int64
	Cca2         field.String
	Cca3         field.String
	Ccn3         field.String
	Flag         field.String
	Continent    field.String
	SubContinent field.String
	MultiLang    field.String
	Independent  field.Bool
	IsActive     field.Bool
	CreatedAt    field.Time
	UpdatedAt    field.Time
	DeletedAt    field.Field

	fieldMap map[string]field.Expr
}

func (g geoCountry) Table(newTableName string) *geoCountry {
	g.geoCountryDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g geoCountry) As(alias string) *geoCountry {
	g.geoCountryDo.DO = *(g.geoCountryDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *geoCountry) updateTableName(table string) *geoCountry {
	g.ALL = field.NewAsterisk(table)
	g.ID = field.NewInt64(table, "id")
	g.Cca2 = field.NewString(table, "cca2")
	g.Cca3 = field.NewString(table, "cca3")
	g.Ccn3 = field.NewString(table, "ccn3")
	g.Flag = field.NewString(table, "flag")
	g.Continent = field.NewString(table, "continent")
	g.SubContinent = field.NewString(table, "sub_continent")
	g.MultiLang = field.NewString(table, "multi_lang")
	g.Independent = field.NewBool(table, "independent")
	g.IsActive = field.NewBool(table, "is_active")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.UpdatedAt = field.NewTime(table, "updated_at")
	g.DeletedAt = field.NewField(table, "deleted_at")

	g.fillFieldMap()

	return g
}

func (g *geoCountry) WithContext(ctx context.Context) IGeoCountryDo {
	return g.geoCountryDo.WithContext(ctx)
}

func (g geoCountry) TableName() string { return g.geoCountryDo.TableName() }

func (g geoCountry) Alias() string { return g.geoCountryDo.Alias() }

func (g geoCountry) Columns(cols ...field.Expr) gen.Columns { return g.geoCountryDo.Columns(cols...) }

func (g *geoCountry) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *geoCountry) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 13)
	g.fieldMap["id"] = g.ID
	g.fieldMap["cca2"] = g.Cca2
	g.fieldMap["cca3"] = g.Cca3
	g.fieldMap["ccn3"] = g.Ccn3
	g.fieldMap["flag"] = g.Flag
	g.fieldMap["continent"] = g.Continent
	g.fieldMap["sub_continent"] = g.SubContinent
	g.fieldMap["multi_lang"] = g.MultiLang
	g.fieldMap["independent"] = g.Independent
	g.fieldMap["is_active"] = g.IsActive
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["updated_at"] = g.UpdatedAt
	g.fieldMap["deleted_at"] = g.DeletedAt
}

func (g geoCountry) clone(db *gorm.DB) geoCountry {
	g.geoCountryDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g geoCountry) replaceDB(db *gorm.DB) geoCountry {
	g.geoCountryDo.ReplaceDB(db)
	return g
}

type geoCountryDo struct{ gen.DO }

type IGeoCountryDo interface {
	gen.SubQuery
	Debug() IGeoCountryDo
	WithContext(ctx context.Context) IGeoCountryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGeoCountryDo
	WriteDB() IGeoCountryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGeoCountryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGeoCountryDo
	Not(conds ...gen.Condition) IGeoCountryDo
	Or(conds ...gen.Condition) IGeoCountryDo
	Select(conds ...field.Expr) IGeoCountryDo
	Where(conds ...gen.Condition) IGeoCountryDo
	Order(conds ...field.Expr) IGeoCountryDo
	Distinct(cols ...field.Expr) IGeoCountryDo
	Omit(cols ...field.Expr) IGeoCountryDo
	Join(table schema.Tabler, on ...field.Expr) IGeoCountryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGeoCountryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGeoCountryDo
	Group(cols ...field.Expr) IGeoCountryDo
	Having(conds ...gen.Condition) IGeoCountryDo
	Limit(limit int) IGeoCountryDo
	Offset(offset int) IGeoCountryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGeoCountryDo
	Unscoped() IGeoCountryDo
	Create(values ...*model.GeoCountry) error
	CreateInBatches(values []*model.GeoCountry, batchSize int) error
	Save(values ...*model.GeoCountry) error
	First() (*model.GeoCountry, error)
	Take() (*model.GeoCountry, error)
	Last() (*model.GeoCountry, error)
	Find() ([]*model.GeoCountry, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GeoCountry, err error)
	FindInBatches(result *[]*model.GeoCountry, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GeoCountry) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGeoCountryDo
	Assign(attrs ...field.AssignExpr) IGeoCountryDo
	Joins(fields ...field.RelationField) IGeoCountryDo
	Preload(fields ...field.RelationField) IGeoCountryDo
	FirstOrInit() (*model.GeoCountry, error)
	FirstOrCreate() (*model.GeoCountry, error)
	FindByPage(offset int, limit int) (result []*model.GeoCountry, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGeoCountryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g geoCountryDo) Debug() IGeoCountryDo {
	return g.withDO(g.DO.Debug())
}

func (g geoCountryDo) WithContext(ctx context.Context) IGeoCountryDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g geoCountryDo) ReadDB() IGeoCountryDo {
	return g.Clauses(dbresolver.Read)
}

func (g geoCountryDo) WriteDB() IGeoCountryDo {
	return g.Clauses(dbresolver.Write)
}

func (g geoCountryDo) Session(config *gorm.Session) IGeoCountryDo {
	return g.withDO(g.DO.Session(config))
}

func (g geoCountryDo) Clauses(conds ...clause.Expression) IGeoCountryDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g geoCountryDo) Returning(value interface{}, columns ...string) IGeoCountryDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g geoCountryDo) Not(conds ...gen.Condition) IGeoCountryDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g geoCountryDo) Or(conds ...gen.Condition) IGeoCountryDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g geoCountryDo) Select(conds ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g geoCountryDo) Where(conds ...gen.Condition) IGeoCountryDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g geoCountryDo) Order(conds ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g geoCountryDo) Distinct(cols ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g geoCountryDo) Omit(cols ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g geoCountryDo) Join(table schema.Tabler, on ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g geoCountryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g geoCountryDo) RightJoin(table schema.Tabler, on ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g geoCountryDo) Group(cols ...field.Expr) IGeoCountryDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g geoCountryDo) Having(conds ...gen.Condition) IGeoCountryDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g geoCountryDo) Limit(limit int) IGeoCountryDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g geoCountryDo) Offset(offset int) IGeoCountryDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g geoCountryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGeoCountryDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g geoCountryDo) Unscoped() IGeoCountryDo {
	return g.withDO(g.DO.Unscoped())
}

func (g geoCountryDo) Create(values ...*model.GeoCountry) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g geoCountryDo) CreateInBatches(values []*model.GeoCountry, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g geoCountryDo) Save(values ...*model.GeoCountry) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g geoCountryDo) First() (*model.GeoCountry, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GeoCountry), nil
	}
}

func (g geoCountryDo) Take() (*model.GeoCountry, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GeoCountry), nil
	}
}

func (g geoCountryDo) Last() (*model.GeoCountry, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GeoCountry), nil
	}
}

func (g geoCountryDo) Find() ([]*model.GeoCountry, error) {
	result, err := g.DO.Find()
	return result.([]*model.GeoCountry), err
}

func (g geoCountryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GeoCountry, err error) {
	buf := make([]*model.GeoCountry, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g geoCountryDo) FindInBatches(result *[]*model.GeoCountry, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g geoCountryDo) Attrs(attrs ...field.AssignExpr) IGeoCountryDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g geoCountryDo) Assign(attrs ...field.AssignExpr) IGeoCountryDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g geoCountryDo) Joins(fields ...field.RelationField) IGeoCountryDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g geoCountryDo) Preload(fields ...field.RelationField) IGeoCountryDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g geoCountryDo) FirstOrInit() (*model.GeoCountry, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GeoCountry), nil
	}
}

func (g geoCountryDo) FirstOrCreate() (*model.GeoCountry, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GeoCountry), nil
	}
}

func (g geoCountryDo) FindByPage(offset int, limit int) (result []*model.GeoCountry, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g geoCountryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g geoCountryDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g geoCountryDo) Delete(models ...*model.GeoCountry) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *geoCountryDo) withDO(do gen.Dao) *geoCountryDo {
	g.DO = *do.(*gen.DO)
	return g
}
